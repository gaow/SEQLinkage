# AUTOGENERATED! DO NOT EDIT! File to edit: nbs/linkage_analysis.ipynb (unless otherwise specified).

__all__ = ['base', 'paramlink2', 'pedprobr', 'pedtools', 'get_allele', 'name_haps', 'get_fam_hap', 'get_fam_geno',
           'format_haps_bunch', 'calculate_ped_lod', 'parallel_lods', 'sum_variant_lods']

# Cell
import numpy as np
import pandas as pd
import pickle
from itertools import repeat
import numbers

#Import necessary packages
import rpy2.robjects as robjects
from rpy2.robjects.packages import importr
from rpy2.robjects import pandas2ri
base = importr('base')
base.options(expressions = 5e5)
#Must be activated
pandas2ri.activate()
paramlink2=importr('paramlink2')
pedprobr=importr('pedprobr')
pedtools = importr('pedtools')

import time
from concurrent.futures import ProcessPoolExecutor,ThreadPoolExecutor

# Cell
def get_allele(s):
    a = s[1] if s[0].isupper() else s[0]
    return 0 if a=='?' else int(a)

def name_haps(snps):
    name = []
    for i in snps:
        name += [i+'_A0',i+'_A1']
    return name

def get_fam_hap(haps,variants,vcf=None):
    new_haps,new_iid = [],[]
    iid = haps[:,1]
    haps = haps[:,2:]
    for i in range(0,haps.shape[0],2):
        cur_iid=iid[i]
        new_iid.append(cur_iid)
        if vcf is None or vcf[cur_iid]:#have vcf
            hap_a01 = []
            for a0,a1 in zip(haps[i],haps[i+1]): #loop through variants
                hap_a01 += [get_allele(a0),get_allele(a1)]
        else:
            hap_a01 = [0,0]*haps.shape[1] #set missing vcf to 0
        new_haps.append(hap_a01)
    new_haps = pd.DataFrame(new_haps)
    new_haps.index = new_iid
    new_haps.columns = name_haps(variants)
    #remove variants with only 1 or 2 as alleles, return None
    idx=[]
    for i in range(0,new_haps.shape[1],2):
        v=set(new_haps.iloc[:,i]).union(set(new_haps.iloc[:,i+1]))
        if 1 not in v or 2 not in v:
            idx.append(False)
        else:
            idx.append(True)
    if sum(idx)==0:
        return None
    return new_haps.loc[:,np.repeat(np.array(idx),2)],idx

def get_fam_geno(haps,variants,vcf=None):
    new_haps,new_iid = [],[]
    iid = haps[:,1]
    haps = haps[:,5:]
    for i in range(haps.shape[0]):
        cur_iid=iid[i]
        new_iid.append(cur_iid)
        if vcf is None or vcf[cur_iid]:#have vcf
            hap_a01 = []
            for a01 in haps[i]: #loop through variants
                hap_a01 += [int(a) for a in a01]
        else:
            hap_a01 = [0,0]*haps.shape[1] #set missing vcf to 0
        new_haps.append(hap_a01)
    new_haps = pd.DataFrame(new_haps)
    new_haps.index = new_iid
    new_haps.columns = name_haps(variants)
    #remove variants with only 1 or 2 as alleles, return None
    idx=[]
    for i in range(0,new_haps.shape[1],2):
        v=set(new_haps.iloc[:,i]).union(set(new_haps.iloc[:,i+1]))
        if 1 not in v or 2 not in v:
            idx.append(False)
        else:
            idx.append(True)
    if sum(idx)==0:
        return None
    return new_haps.loc[:,np.repeat(np.array(idx),2)],idx

# Cell
def format_haps_bunch(dhaps,fam,vcfs=None,cutoff=None,haplotype=True):
    gene_variants = {}
    gene_haps = {}
    for g in dhaps.keys():
        haps = dhaps[g]['predata']
        with ProcessPoolExecutor(max_workers = 10) as executor:
            if haplotype:
                results = executor.map(get_fam_hap,[haps[k][2] for k in haps.keys()],[haps[k][0] for k in haps.keys()],[vcfs[k] if vcfs else None for k in haps.keys()])
            else:
                results = executor.map(get_fam_geno,[haps[k][2] for k in haps.keys()],[haps[k][0] for k in haps.keys()],[vcfs[k] if vcfs else None for k in haps.keys()])
        for f,hap in  zip(haps.keys(),results):
            if hap is None: #remove only have 1 or 2 variants
                continue
            if f not in gene_variants.keys():
                gene_variants[f] = {'genes':[],'variants':[],'freqs':[]}
                gene_haps[f] = hap[0]
            else:
                gene_haps[f] = pd.concat([gene_haps[f],hap[0]],axis=1)
            idx=hap[1] #False for variants only have 1 or 2.
            gene_variants[f]['genes'] += [g]*sum(idx)
            gene_variants[f]['variants'] += list(haps[f][0][idx])
            gene_variants[f]['freqs'] += list(haps[f][1][idx])
    for i,j in gene_variants.items():
        j=pd.DataFrame(j)
        if cutoff is not None:
            frq_idx=np.array(j['freqs'])>cutoff
            j=j.loc[frq_idx,:]
            gene_haps[i]=gene_haps[i].loc[:,np.repeat(frq_idx,2)]
        redup_idx = ~gene_haps[i].columns.duplicated()
        gene_haps[i] = pd.concat([fam[i],gene_haps[i].iloc[:,redup_idx]],axis=1)
        j['uniq'] = list(redup_idx[range(0,len(redup_idx),2)])
        gene_variants[i] = j
    return gene_variants,gene_haps



def calculate_ped_lod(ped,afreq=None,rho=0,model = "AD",chrom = "AUTOSOMAL",penetrances = [0.01,0.9,0.9],dfreq=0.001):
    aff=ped.iloc[:,5]
    mped = pedtools.as_ped(ped.drop(ped.columns[5], axis=1),famid_col = 1,id_col = 2,fid_col = 3,mid_col = 4,sex_col = 5)
    if afreq is not None:
        mped = pedtools.setLocusAttributes(mped,locusAttributes=[base.list(afreq=base.c(1-i,i)) for i in afreq])
    modAD = paramlink2.diseaseModel(model,chrom,pd.Series(penetrances),dfreq)
    if isinstance(rho,numbers.Number):
        res = _calculate_ped_lod(mped, aff = aff, model = modAD,rho=rho)
    else:
        res=None
        for r in rho:
            tmp = _calculate_ped_lod(mped, aff = aff, model = modAD,rho=r)
            if res is None:
                res=tmp
                res.columns = ['MARKER','LOD'+str(round(r,2))]
            else:
                res['LOD'+str(round(r,2))]=tmp.LOD
        res.index=list(res.MARKER)
        res=res.iloc[:,1:]
    return res

def _calculate_ped_lod(mped, aff, model,rho):
    res = paramlink2.lod(mped, aff, model,rho)
    try:
        res = pd.DataFrame(res)[['MARKER','LOD']]
    except:
        res = pd.DataFrame([[ped.columns[6],res[0]]],columns=['MARKER','LOD'])
    return res

def parallel_lods(haps,afreqs=None,rho=0):
    start = time.perf_counter()
    if afreqs is None:
        with ProcessPoolExecutor(max_workers = 10) as executor:
            results = executor.map(calculate_ped_lod,haps.values(),repeat(rho))
    else:
        with ProcessPoolExecutor(max_workers = 10) as executor:
            results = executor.map(calculate_ped_lod,haps.values(),afreqs,repeat(rho))
    print(time.perf_counter()-start)
    return {k:res for k,res in zip(haps.keys(),results)}

def sum_variant_lods(lods):
    variants = {}
    for lod in lods:
        for m,l in zip(lod['MARKER'],lod['LOD']):
            if m in variants.keys():
                variants[m] += l
            else:
                variants[m] = l
    var_lst = []
    for var,lod in variants.items():
        snp = var[:-3]
        var_lst.append(snp.split(':')+[snp,lod])
    variants=pd.DataFrame(var_lst,columns=['CHR','POS','A0','A1','SNP','LOD'])
    variants.POS = variants.POS.astype(int)
    variants.sort_values('POS')
    return variants